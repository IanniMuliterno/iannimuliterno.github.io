---
layout: post
title: Fast and furious - data.table is THE thing.
tags: [programação,eficiência,R,Python]
---  
https://rstudio-pubs-static.s3.amazonaws.com/406521_7fc7b6c1dc374e9b8860e15a699d8bb0.html
<br>
https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html
<br>
https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly
<br>
https://atrebas.github.io/post/2019-03-03-datatable-dplyr/

 Cientista de dados, aquele ser iluminado que muitos leigos imaginam como um super-geek por trás dos modelos solucionadores de mistérios. Bom isso acontece, mas o que pouca gente conta é que um bom pedaço do tempo desse profissional é investido em dataPrep, nada cool, costuma ser demorado e delicado, essa última parte quer dizer que "não, não da para automatizar 100% do dataPrep, o ideal é sempre ter um humano se certificando de que tudo está bem".
DataPrep traz insights e para evitar dores de cabeça futuras tem de feito com calma, o que quer dizer que não é bom simplesmente sair confiando em algumas das milhares de bibliotecas que prometem entregar uma base limpa. É inevitável analisar alguns histogramas, estudar dados faltantes, fazer filtros, agrupamentos e tudo o mais.  

 É aí que entra o data.table. Ah, data.table! Essa belezinha simplesmente é o jeito mais legal de virar sua base de dados ao avesso de forma "braçal", é uma biblioteca que permite ao usuário adotar uma 'linguagem' de manipulção de base que é curta e, na grande maioria das vezes, bem mais rápida do que qualquer outro método de manipulação de base.

 Ok, ok, isso é fala de fã, admito. O que vou fazer aqui então é dar uma pequena demonstração de como um comando pode ser passado de dplyr para datatable de forma simples, uma vez que se entende a estrutura, e como isso faz diferença no desempenho do script. Para isso vamos começar construindo uma base de 20 milhões de linhas e 10 colunas.
 
 ```r
 library(data.table)
library(dplyr)
library(purrr) # For map() function
library(microbenchmark) # For benchmarking
library(tidyverse)

dfs <- rep(2e7,10)

set.seed(123456)
myList <- map(dfs,   #amostra de 20kk de valores no range de 1:1e5, 10 vezes
              base::sample,
              x = 1:1e5,
              replace = TRUE) %>%
  map(matrix,  # em cada posicao da lista, quebra o vetor em 10 e joga cada parte como coluna de uma matriz
      ncol = 10) %>%
  map(data.frame)  # transforma todas matrizes da lista em data.frames
  
  df3 <- data.table::rbindlist(myList) # une as bases na lista
 ```
 Antes de prosseguir, vamos dar uma olhada na base.
 
 ```r
  df3
             X1    X2    X3    X4    X5    X6    X7    X8    X9   X10
       1: 87921 55793 81282 39316 43389 54449 60047 18947 21528 46857
       2: 78535 91446 36566 17892  6147 33818 67607 22926 26595 30526
       3:  6326 76229 60797 92675  1069 23344 51051 30793 47039 52544
       4: 76518 66161 48164 35810 32729 87865 21972 73380 88603 11411
       5: 57728  2418 17606 59877 72380 39148 85925  4679   824 28162
      ---                                                            
19999996: 61381 43589 70131 41942 32774 19965  4749 52238 50814 50884
19999997: 45927  4094 38977 76729 90735 21795  9222 63427 70221 26999
19999998: 99080 70908  9367 14237 39944 77173 36196 95234 31328 47128
19999999: 60724 37080  4661 49043 70521 87968 38904 10466 16827 46864
20000000:  4670 63739 27229 73348 72747 21393 29047 91010 44935 96431
```
 Agora suponha que estamos na fase de dataPrep desta base, tentando descobrir coisas sobre ela como : " Qual o valor minimo de X3 agrupado por X1?". Vamos escrever isso em dplyr e datatable para entender como é simples traduzir de um para o outro.
 
 ```r
 # escrevendo em datatable 
teste1 <- df3[,.(min_X3 = min(X3)),.(X1)][order(X1)]

# escrevendo em dplyr
teste2 <- df3 %>% 
          group_by(X1) %>%
          summarize(min_X3 = min(X3))
          
# conferindo se as saídas são iguais          
all.equal(teste1,as.data.table(teste2))
[1] TRUE
 ```
 Detalhando o que acontece no código acima, partindo do entendimento de dplyr
 
 ```r
 output <- data %>%                         # primeiro passo: Fornecer a base a ser manipulada
           group_by(var) %>%                  # segundo passo: informar variável de agrupamento
           summarize( var_label = func(var2))   # terceiro passo: aplicar função na variável de interesse, dando resultado por grupo.

#a tradução para datatable pode ser confusa no princípio porque apesar de ter uma ordem cronológica, esta não é tão organizada.

# estrutura básica para operar com datatable 
data[filtro, .(summarize), .(group_by)] 

# por isso quando declaramos teste1, precisamos começar com vírgula, para indicar que não queremos filtros no nosso cálculo.
Fora isso basta copiar o que você colocaria no 'summarize' para o espaço após a primeira virgula e copiar o que você
colocaria no 'group_by' após a segunda vírgula.

# lógica cronológica do datatable
data[ tudo que acontece aqui é o passo 1][passo 2, mesma estrutura e usa como base a saída do passo 1] ... [passo n, mesma estrutura e 
usa como base a saída do passo n - 1]
```

 Agora que já sabemos como gerar a mesma operação por grupo, vamos comparar o desempenho com microbenchmark, esta função executa uma expressão um dado número de vezes e conta o tempo gasto em cada iteração. Para esse caso, foram feitas 100 execuções de cada expressão.
 
 ```r
 time_champs <- microbenchmark({
 df3[,.(min_X3 = min(X3)),.(X1)][order(X1)]
 }, times = 100L)

time_nonchamps <- microbenchmark({
    df3 %>% 
    group_by(X1) %>%
    summarize(min_X3 = min(X3))
    }, times = 100L)
 ```

histogramas

 A coisa fica pior se tivermos interesse num grupo maior e em mais resultados no summarize.
 
 ```r
 time_champs2 <- microbenchmark({
                df3[,.(min_X3 = min(X3),
                       max_X3 = max(X3)),.(X1,X2)][order(X1,X2)]
}, times = 10L)

time_nonchamps2 <- microbenchmark({
                   df3 %>% 
                       group_by(X1,X2) %>%
                       summarize(min_X3 = min(X3),
                                 max_X3 = max(X3))
}, times = 10L)
 ```
Vale ressaltar que o data.table é tudo isso sim, mas ele não é para big data, ele é um last resort, se ficar impraticável com data.table é porque tem que partir uma ferramenta específica para manipular big data. 

## data table para Python
### benchmark
### alguns exemplos


### não esquecer de referenciar fontes
